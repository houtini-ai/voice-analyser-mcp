/**
 * Vulnerability & Admission Pattern Analyzer
 * Detects honest admissions, mistakes, uncertainty, and limitations
 * Universal across domains: academic, tech reviews, creative writing, etc.
 */

export interface VulnerabilityPattern {
  type: 'mistake_admission' | 'uncertainty_marker' | 'limitation_statement';
  phrase: string;
  context: string;
  frequency: number;
}

export interface VulnerabilityAnalysis {
  mistakeAdmissions: VulnerabilityPattern[];
  uncertaintyMarkers: VulnerabilityPattern[];
  limitationStatements: VulnerabilityPattern[];
  vulnerabilityScore: number; // 0-1 scale
  totalCount: number;
  interpretation: string;
  guidanceText: string;
}

export function analyzeVulnerabilityPatterns(text: string): VulnerabilityAnalysis {
  const mistakeAdmissions = detectMistakeAdmissions(text);
  const uncertaintyMarkers = detectUncertaintyMarkers(text);
  const limitationStatements = detectLimitationStatements(text);
  
  const totalCount = 
    mistakeAdmissions.reduce((sum, p) => sum + p.frequency, 0) +
    uncertaintyMarkers.reduce((sum, p) => sum + p.frequency, 0) +
    limitationStatements.reduce((sum, p) => sum + p.frequency, 0);
  
  const wordCount = text.split(/\s+/).length;
  const vulnerabilityScore = Math.min(1.0, totalCount / (wordCount / 100)); // per 100 words, capped at 1.0
  
  const interpretation = interpretVulnerabilityScore(vulnerabilityScore);
  const guidanceText = generateGuidance(vulnerabilityScore, mistakeAdmissions, uncertaintyMarkers, limitationStatements);
  
  return {
    mistakeAdmissions,
    uncertaintyMarkers,
    limitationStatements,
    vulnerabilityScore,
    totalCount,
    interpretation,
    guidanceText
  };
}

function detectMistakeAdmissions(text: string): VulnerabilityPattern[] {
  const patterns: VulnerabilityPattern[] = [];
  
  const mistakePatterns = [
    /\b(i\s+was\s+wrong|i\s+made\s+a\s+mistake|i\s+messed\s+up)\b/gi,
    /\b(didn't\s+work|failed|broke)\b/gi,
    /\b(turns\s+out\s+i\s+was|turned\s+out\s+to\s+be)\b/gi,
    /\b(my\s+mistake|my\s+error|my\s+bad)\b/gi,
    /\b(i\s+should\s+have|i\s+shouldn't\s+have)\b/gi,
    /\b(regret|wish\s+i\s+had|wish\s+i\s+hadn't)\b/gi
  ];
  
  for (const pattern of mistakePatterns) {
    let match;
    const regex = new RegExp(pattern.source, pattern.flags);
    while ((match = regex.exec(text)) !== null) {
      const phrase = match[0];
      const context = extractContext(text, match.index, 100);
      
      const existing = patterns.find(p => p.phrase.toLowerCase() === phrase.toLowerCase());
      if (existing) {
        existing.frequency++;
      } else {
        patterns.push({
          type: 'mistake_admission',
          phrase: phrase,
          context: context,
          frequency: 1
        });
      }
    }
  }
  
  return patterns.sort((a, b) => b.frequency - a.frequency);
}

function detectUncertaintyMarkers(text: string): VulnerabilityPattern[] {
  const patterns: VulnerabilityPattern[] = [];
  
  const uncertaintyPatterns = [
    /\b(i'm\s+not\s+sure|not\s+certain|uncertain|unclear)\b/gi,
    /\b(might\s+be|could\s+be|possibly|perhaps)\b/gi,
    /\b(i\s+think|i\s+believe|i\s+suspect|i\s+guess)\b/gi,
    /\b(seems\s+like|appears\s+to|looks\s+like)\b/gi,
    /\b(hard\s+to\s+say|difficult\s+to\s+know|can't\s+be\s+sure)\b/gi,
    /\b(tentatively|provisionally|speculatively)\b/gi,
    /\b(remains\s+to\s+be\s+seen|time\s+will\s+tell)\b/gi
  ];
  
  for (const pattern of uncertaintyPatterns) {
    let match;
    const regex = new RegExp(pattern.source, pattern.flags);
    while ((match = regex.exec(text)) !== null) {
      const phrase = match[0];
      const context = extractContext(text, match.index, 100);
      
      const existing = patterns.find(p => p.phrase.toLowerCase() === phrase.toLowerCase());
      if (existing) {
        existing.frequency++;
      } else {
        patterns.push({
          type: 'uncertainty_marker',
          phrase: phrase,
          context: context,
          frequency: 1
        });
      }
    }
  }
  
  return patterns.sort((a, b) => b.frequency - a.frequency);
}

function detectLimitationStatements(text: string): VulnerabilityPattern[] {
  const patterns: VulnerabilityPattern[] = [];
  
  const limitationPatterns = [
    /\b(however|but\s+there's\s+a\s+problem|downside|drawback)\b/gi,
    /\b(limitation|constraint|caveat|trade-off)\b/gi,
    /\b(doesn't\s+work\s+for|won't\s+work\s+if|not\s+suitable\s+for)\b/gi,
    /\b(couldn't\s+test|didn't\s+have\s+time|wasn't\s+able)\b/gi,
    /\b(your\s+mileage\s+may\s+vary|results\s+may\s+differ)\b/gi,
    /\b(further\s+research|more\s+testing|additional\s+work)\s+(needed|required|necessary)\b/gi
  ];
  
  for (const pattern of limitationPatterns) {
    let match;
    const regex = new RegExp(pattern.source, pattern.flags);
    while ((match = regex.exec(text)) !== null) {
      const phrase = match[0];
      const context = extractContext(text, match.index, 100);
      
      const existing = patterns.find(p => p.phrase.toLowerCase() === phrase.toLowerCase());
      if (existing) {
        existing.frequency++;
      } else {
        patterns.push({
          type: 'limitation_statement',
          phrase: phrase,
          context: context,
          frequency: 1
        });
      }
    }
  }
  
  return patterns.sort((a, b) => b.frequency - a.frequency);
}

function extractContext(text: string, position: number, contextLength: number): string {
  const start = Math.max(0, position - contextLength);
  const end = Math.min(text.length, position + contextLength * 2);
  let context = text.substring(start, end).trim();
  
  // Clean up partial sentences
  const firstPeriod = context.indexOf('. ');
  if (firstPeriod > 0 && firstPeriod < 50) {
    context = context.substring(firstPeriod + 2);
  }
  
  return '...' + context + '...';
}

function interpretVulnerabilityScore(score: number): string {
  if (score > 0.8) {
    return 'Very high vulnerability - extremely honest and transparent about limitations';
  } else if (score > 0.5) {
    return 'High vulnerability - regularly admits mistakes and uncertainties';
  } else if (score > 0.3) {
    return 'Moderate vulnerability - balanced confidence with honest admissions';
  } else if (score > 0.1) {
    return 'Low vulnerability - predominantly confident assertions';
  } else {
    return 'Very low vulnerability - rarely admits limitations or uncertainty';
  }
}

function generateGuidance(
  score: number,
  mistakes: VulnerabilityPattern[],
  uncertainty: VulnerabilityPattern[],
  limitations: VulnerabilityPattern[]
): string {
  const lines: string[] = [];
  
  lines.push('### Vulnerability & Honesty Pattern\n');
  
  if (score > 0.4) {
    lines.push('**Voice Characteristic:** This writer builds trust through honest admissions.');
    lines.push('');
    lines.push('**How to replicate:**');
    lines.push('- Admit when tests failed or expectations were wrong');
    lines.push('- State limitations openly ("couldn\'t test X", "your mileage may vary")');
    lines.push('- Use uncertainty markers when genuinely uncertain');
    lines.push('- Perfect narratives signal marketing, not authentic experience');
    lines.push('');
  } else if (score > 0.2) {
    lines.push('**Voice Characteristic:** Balanced confidence with selective honesty.');
    lines.push('');
    lines.push('**How to replicate:**');
    lines.push('- State confident conclusions from tested scenarios');
    lines.push('- Acknowledge limitations when they matter to reader');
    lines.push('- Use hedging ("might", "could") sparingly for genuine uncertainty');
    lines.push('');
  } else {
    lines.push('**Voice Characteristic:** Authoritative, confident, minimal hedging.');
    lines.push('');
    lines.push('**How to replicate:**');
    lines.push('- State conclusions directly without hedging');
    lines.push('- Avoid unnecessary uncertainty markers');
    lines.push('- Present tested findings as established facts');
    lines.push('');
  }
  
  if (mistakes.length > 0) {
    lines.push('**Mistake Admission Patterns:**');
    for (const pattern of mistakes.slice(0, 5)) {
      lines.push(`- "${pattern.phrase}" (${pattern.frequency} uses)`);
    }
    lines.push('');
  }
  
  if (uncertainty.length > 0) {
    lines.push('**Uncertainty Markers:**');
    for (const pattern of uncertainty.slice(0, 5)) {
      lines.push(`- "${pattern.phrase}" (${pattern.frequency} uses)`);
    }
    lines.push('');
  }
  
  if (limitations.length > 0) {
    lines.push('**Limitation Statements:**');
    for (const pattern of limitations.slice(0, 5)) {
      lines.push(`- "${pattern.phrase}" (${pattern.frequency} uses)`);
    }
    lines.push('');
  }
  
  return lines.join('\n');
}